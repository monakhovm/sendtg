name: Redeliver Failed Webhook for This Event

on:
  # –î–û–î–ê–ô —Å—é–¥–∏ –≤—Å—ñ –ø–æ–¥—ñ—ó, –ø—ñ—Å–ª—è —è–∫–∏—Ö —Ö–æ—á–µ—à –ø–µ—Ä–µ–≤—ñ—Ä–∫—É/–ø–µ—Ä–µ–≤—ñ–¥–ø—Ä–∞–≤–∫—É
  push:
  pull_request:
    types: [opened, reopened, synchronize, closed, edited, labeled, unlabeled]
  # –∑–∞ –ø–æ—Ç—Ä–µ–±–∏ –¥–æ–¥–∞–π —ñ–Ω—à—ñ –ø–æ–¥—ñ—ó –∑ docs

jobs:
  check_and_redeliver:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: üîÑ –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ç–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∞ –≤–µ–±—Ö—É–∫–∞ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ—ó –ø–æ–¥—ñ—ó
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WEBHOOK_ADMIN_TOKEN }} # PAT/FGT –∑ –ø—Ä–∞–≤–∞–º–∏ –Ω–∞ Webhooks Read+Write
          script: |
            const MAX_ATTEMPTS = 10;
            const RECENT_SECONDS = 15 * 60; // 15 —Ö–≤ –≤—ñ–∫–Ω–æ –Ω–∞ —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—é
            const BASE_DELAY_MS = 3000;     // —Å—Ç–∞—Ä—Ç–æ–≤–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é –Ω–æ–≤–æ—ó –¥–æ—Å—Ç–∞–≤–∫–∏
            const headers = { 'X-GitHub-Api-Version': '2022-11-28' };

            const { owner, repo } = context.repo;
            const eventName = context.eventName; // push, pull_request, issues, release, ...
            const now = Date.now();

            // –í–∏—Ç—è–≥—É—î–º–æ "–∫–ª—é—á" –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ—ó –ø–æ–¥—ñ—ó, —â–æ–± –∑—ñ—Å—Ç–∞–≤–∏—Ç–∏ –∑ payload –¥–æ—Å—Ç–∞–≤–∫–∏
            function eventKeyFromContext() {
              const p = context.payload;
              switch (eventName) {
                case 'pull_request':
                  return { event: 'pull_request', action: p.action, pr: p.pull_request?.number };
                case 'push':
                  // —Å–ø—ñ–≤—Å—Ç–∞–≤–ª—è—î–º–æ –∑–∞ after SHA —ñ ref
                  return { event: 'push', after: p.after, ref: p.ref };
                default:
                  // –ó–∞ –ø–æ—Ç—Ä–µ–±–∏ –¥–æ–¥–∞–π —ñ–Ω—à—ñ –ø–æ–¥—ñ—ó
                  return { event: eventName };
              }
            }

            function isRecent(iso) {
              const t = Date.parse(iso);
              return Number.isFinite(t) && ((now - t) / 1000) <= RECENT_SECONDS;
            }

            function isSuccess(delivery) {
              return delivery.status === 'OK' && delivery.status_code >= 200 && delivery.status_code < 300;
            }

            async function listRepoHooks() {
              const { data } = await github.request('GET /repos/{owner}/{repo}/hooks', { owner, repo, headers });
              return data;
            }

            async function listDeliveries(hookId, perPage = 100) {
              const { data } = await github.request(
                'GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries',
                { owner, repo, hook_id: hookId, per_page: perPage, headers }
              );
              return data;
            }

            async function getDelivery(hookId, deliveryId) {
              const { data } = await github.request(
                'GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}',
                { owner, repo, hook_id: hookId, delivery_id: deliveryId, headers }
              );
              return data;
            }

            async function redeliver(hookId, deliveryId) {
              // –ø–æ–≤–µ—Ä—Ç–∞—î 202 Accepted
              await github.request(
                'POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts',
                { owner, repo, hook_id: hookId, delivery_id: deliveryId, headers }
              );
            }

            // –ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è payload –¥–æ—Å—Ç–∞–≤–∫–∏ –∑ –ø–æ—Ç–æ—á–Ω–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
            function matchesThisEvent(fullDelivery, thisKey) {
              const req = fullDelivery?.request?.payload || {};
              if (fullDelivery.event !== thisKey.event) return false;

              switch (thisKey.event) {
                case 'pull_request':
                  return req.action === thisKey.action &&
                         req.pull_request?.number === thisKey.pr;
                case 'issues':
                  return req.action === thisKey.action &&
                         req.issue?.number === thisKey.issue;
                case 'issue_comment':
                  // –∑–≤—ñ—Ä—è—î–º–æ issue —ñ (–æ–ø—Ü—ñ–π–Ω–æ) –∫–æ–º–µ–Ω—Ç–∞—Ä
                  if (req.action !== thisKey.action) return false;
                  if (typeof thisKey.issue === 'number' && req.issue?.number !== thisKey.issue) return false;
                  return true;
                case 'push':
                  // –¥–µ—è–∫—ñ payload-–∏ –º–æ–∂—É—Ç—å –Ω–µ –º–∞—Ç–∏ 'after' —É –¥–æ—Å—Ç–∞–≤—Ü—ñ, –∞–ª–µ –º–∞—é—Ç—å ref
                  if (thisKey.after && req.after && req.after !== thisKey.after) return false;
                  if (thisKey.ref && req.ref && req.ref !== thisKey.ref) return false;
                  return true;
                case 'release':
                  if (req.action !== thisKey.action) return false;
                  if (thisKey.id && req.release?.id !== thisKey.id) return false;
                  if (thisKey.tag && req.release?.tag_name !== thisKey.tag) return false;
                  return true;
                default:
                  // –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º: —Ç—ñ–ª—å–∫–∏ –∑–±—ñ–≥ —Ç–∏–ø—É –ø–æ–¥—ñ—ó
                  return true;
              }
            }

            const thisKey = eventKeyFromContext();

            let anyTriggered = false;
            const hooks = await listRepoHooks();

            for (const hook of hooks) {
              if (hook.active === false) continue;
              if (Array.isArray(hook.events) && !hook.events.includes(thisKey.event) && !hook.events.includes('*')) continue;

              // 1) –ë–µ—Ä–µ–º–æ –Ω–µ–¥–∞–≤–Ω—ñ –¥–æ—Å—Ç–∞–≤–∫–∏ –¥–ª—è —Ü—å–æ–≥–æ hook
              const recent = (await listDeliveries(hook.id, 100))
                .filter(d => d.event === thisKey.event && isRecent(d.delivered_at))
                .sort((a,b) => Date.parse(b.delivered_at) - Date.parse(a.delivered_at));

              // 2) –ó–Ω–∞—Ö–æ–¥–∏–º–æ –æ—Å—Ç–∞–Ω–Ω—é –¥–æ—Å—Ç–∞–≤–∫—É —Å–∞–º–µ –¥–ª—è –Ω–∞—à–æ–≥–æ —Ä–µ—Å—É—Ä—Å—É/–¥—ñ—ó
              let lastMatch = null;
              for (const cand of recent) {
                const full = await getDelivery(hook.id, cand.id); // —â–æ–± –º–∞—Ç–∏ payload.action, pr/issue/sha —Ç–æ—â–æ
                if (matchesThisEvent(full, thisKey)) { lastMatch = full; break; }
              }
              if (!lastMatch) continue;

              // 3) –Ø–∫—â–æ –≤–∂–µ —É—Å–ø—ñ—à–Ω–æ ‚Äî –æ–∫
              if (isSuccess(lastMatch)) continue;

              // 4) –Ü–Ω–∞–∫—à–µ ‚Äî —Ä–µ–¥–æ—Å—Ç–∞–≤–∫–∞ –∑ –ø–æ–ª—ñ–Ω–≥–æ–º (‚â§10 —Ä–∞–∑—ñ–≤)
              anyTriggered = true;
              let attempts = 0;
              let cursorId = lastMatch.id;

              while (attempts < MAX_ATTEMPTS) {
                attempts++;
                core.info(`Webhook ${hook.id} -> redelivery attempt ${attempts} for delivery ${cursorId}`);
                try {
                  await redeliver(hook.id, cursorId); // 202 Accepted, —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è –Ω–æ–≤–∏–π –∑–∞–ø–∏—Å –¥–æ—Å—Ç–∞–≤–∫–∏
                } catch (e) {
                  core.setFailed(`Redelivery API error: ${e.message}`);
                  break;
                }

                // –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–∏–π backoff –¥–æ ~3s * 2^n (cap 30s)
                const waitMs = Math.min(30000, BASE_DELAY_MS * (2 ** (attempts - 1)));
                await new Promise(r => setTimeout(r, waitMs));

                // –ü–µ—Ä–µ—á–∏—Ç—É—î–º–æ –Ω–∞–π–Ω–æ–≤—ñ—à—ñ –¥–æ—Å—Ç–∞–≤–∫–∏ –π —à—É–∫–∞—î–º–æ –°–ê–ú–ï –ù–ê–®–£ –ø–æ–¥—ñ—é
                const head = (await listDeliveries(hook.id, 20))
                  .sort((a,b) => Date.parse(b.delivered_at) - Date.parse(a.delivered_at));

                let newestFull = null;
                for (const d of head) {
                  if (d.event !== thisKey.event || !isRecent(d.delivered_at)) continue;
                  const full = await getDelivery(hook.id, d.id);
                  if (matchesThisEvent(full, thisKey)) { newestFull = full; break; }
                }

                if (!newestFull) {
                  core.info('No matching new delivery found yet; will retry if attempts remain.');
                  continue;
                }

                if (isSuccess(newestFull)) {
                  core.info('‚úÖ Webhook delivery succeeded after redelivery.');
                  break;
                }

                // –≥–æ—Ç—É—î–º–æ—Å—å –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó —Å–ø—Ä–æ–±–∏ –≤—ñ–¥ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –∑–∞–ø–∏—Å—É
                cursorId = newestFull.id;

                if (attempts === MAX_ATTEMPTS) {
                  core.setFailed(`‚ùå Webhook ${hook.id} (${hook.config?.url}) still failing after ${MAX_ATTEMPTS} attempts for ${thisKey.event}.`);
                }
              }
            }

            if (!anyTriggered) {
              core.info('No recent failed deliveries found for THIS event.');
            }
