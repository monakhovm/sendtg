name: Redeliver Failed Webhook for This Event

on:
  push:
  pull_request:
    types: [opened, reopened, closed]

jobs:
  check_and_redeliver:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: üîÑ –ü–æ—Å–ª—ñ–¥–æ–≤–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Ç–∞ –ø–µ—Ä–µ–≤—ñ–¥–ø—Ä–∞–≤–∫–∞ –¥–ª—è –≤—Å—ñ—Ö –≤–µ–±—Ö—É–∫—ñ–≤
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WEBHOOK_ADMIN_TOKEN }} # –º–∞—î –º–∞—Ç–∏ Webhooks Read + Write
          script: |
            // ----- –ü–ê–†–ê–ú–ï–¢–†–ò -----
            const MAX_ATTEMPTS = 3;
            const RECENT_SECONDS = 15 * 60; // 15 —Ö–≤ ‚Äî –≤—ñ–∫–Ω–æ –¥–ª—è "—Ü—ñ—î—ó" –ø–æ–¥—ñ—ó
            const BASE_DELAY_MS = 3000;     // —Å—Ç–∞—Ä—Ç–æ–≤–∏–π backoff, –∑—Ä–æ—Å—Ç–∞—î –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–æ –¥–æ 30s
            const API_VERSION = '2022-11-28';

            // ----- –ö–û–ù–¢–ï–ö–°–¢ -----
            const { owner, repo } = context.repo;
            const eventName = context.eventName;
            const now = Date.now();
            const headers = { 'X-GitHub-Api-Version': API_VERSION };

            // ----- –£–¢–ò–õ–Ü–¢–ò API -----
            const listRepoHooks = async () => {
              const { data } = await github.request('GET /repos/{owner}/{repo}/hooks', { owner, repo, headers });
              return data;
            };
            const listDeliveries = async (hookId, perPage = 100) => {
              const { data } = await github.request('GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries', {
                owner, repo, hook_id: hookId, per_page: perPage, headers
              });
              return data;
            };
            const getDelivery = async (hookId, deliveryId) => {
              const { data } = await github.request('GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}', {
                owner, repo, hook_id: hookId, delivery_id: deliveryId, headers
              });
              return data;
            };
            const triggerRedelivery = async (hookId, deliveryId) => {
              await github.request('POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts', {
                owner, repo, hook_id: hookId, delivery_id: deliveryId, headers
              });
            };

            // ----- –•–ï–õ–ü–ï–†–ò –ü–û–†–Ü–í–ù–Ø–ù–ù–Ø -----
            const isRecent = iso => {
              const t = Date.parse(iso);
              return Number.isFinite(t) && ((now - t) / 1000) <= RECENT_SECONDS;
            };
            const isSuccess = d => d.status === 'OK' && d.status_code >= 200 && d.status_code < 300;

            // –ü–æ—Ç–æ—á–Ω–∏–π "–∫–ª—é—á" –ø–æ–¥—ñ—ó –¥–ª—è –∑—ñ—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –∑ payload-–æ–º –¥–æ—Å—Ç–∞–≤–∫–∏
            const thisKey = (() => {
              const p = context.payload;
              switch (eventName) {
                case 'pull_request':
                  return { event: 'pull_request', action: p.action, pr: p.pull_request?.number };
                case 'push':
                  return { event: 'push', after: p.after, ref: p.ref };
                default:
                  return { event: eventName };
              }
            })();

            const matchesThisEvent = (fullDelivery, key) => {
              if (fullDelivery.event !== key.event) return false;
              const req = fullDelivery?.request?.payload || {};
              switch (key.event) {
                case 'pull_request':
                  return req.action === key.action && req.pull_request?.number === key.pr;
                case 'issues':
                  return req.action === key.action && req.issue?.number === key.issue;
                case 'issue_comment':
                  if (req.action !== key.action) return false;
                  if (typeof key.issue === 'number' && req.issue?.number !== key.issue) return false;
                  return true;
                case 'push':
                  if (key.after && req.after && req.after !== key.after) return false;
                  if (key.ref && req.ref && req.ref !== key.ref) return false;
                  return true;
                case 'release':
                  if (req.action !== key.action) return false;
                  if (key.id && req.release?.id !== key.id) return false;
                  if (key.tag && req.release?.tag_name !== key.tag) return false;
                  return true;
                default:
                  return true;
              }
            };

            // ----- –ü–û–®–£–ö –û–°–¢–ê–ù–ù–¨–û–á –í–Ü–î–ü–û–í–Ü–î–ù–û–á –î–û–°–¢–ê–í–ö–ò –î–õ–Ø –ö–û–ù–ö–†–ï–¢–ù–û–ì–û –•–£–ö–ê -----
            const findLatestMatchingDelivery = async (hookId, key) => {
              const candidates = (await listDeliveries(hookId, 100))
                .filter(d => d.event === key.event && isRecent(d.delivered_at))
                .sort((a,b) => Date.parse(b.delivered_at) - Date.parse(a.delivered_at));
              for (const cand of candidates) {
                const full = await getDelivery(hookId, cand.id);
                if (matchesThisEvent(full, key)) return full;
              }
              return null;
            };

            // ----- –û–°–ù–û–í–ù–ê –§–£–ù–ö–¶–Ü–Ø –†–ï–î–û–°–¢–ê–í–ö–ò –î–õ–Ø –û–î–ù–û–ì–û –í–ï–ë–•–£–ö–ê -----
            async function redeliverForHook(hook, key) {
              // –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏, —è–∫—â–æ —Ö—É–∫ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π –∞–±–æ –Ω–µ —Å–ª—É—Ö–∞—î —Ü—é –ø–æ–¥—ñ—é
              if (hook.active === false) return { processed: false, message: 'inactive' };
              if (Array.isArray(hook.events) && !hook.events.includes(key.event) && !hook.events.includes('*')) {
                return { processed: false, message: 'event not subscribed' };
              }

              const last = await findLatestMatchingDelivery(hook.id, key);
              if (!last) return { processed: true, message: 'no matching recent delivery' };
              if (isSuccess(last)) return { processed: true, message: 'already successful' };

              // —Ä–µ–¥–æ—Å—Ç–∞–≤–∫–∞ –∑ backoff –¥–æ MAX_ATTEMPTS
              let attempts = 0;
              let cursorId = last.id;

              while (attempts < MAX_ATTEMPTS) {
                attempts++;
                core.info(`Webhook ${hook.id} ‚Üí attempt ${attempts} for delivery ${cursorId}`);
                try {
                  await triggerRedelivery(hook.id, cursorId);
                } catch (e) {
                  const msg = `API error: ${e.message}`;
                  core.warning(msg);
                  return { processed: true, failed: true, message: msg };
                }

                // –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–π–Ω–∏–π backoff (cap 30s)
                const waitMs = Math.min(30000, BASE_DELAY_MS * (2 ** (attempts - 1)));
                await new Promise(r => setTimeout(r, waitMs));

                // –ø–µ—Ä–µ—á–∏—Ç—É—î–º–æ –≤–µ—Ä—Ö—ñ–≤–∫—É –¥–æ—Å—Ç–∞–≤–æ–∫ —ñ —à—É–∫–∞—î–º–æ ¬´–Ω–∞—à—É¬ª –Ω–∞–π–Ω–æ–≤—ñ—à—É
                const head = (await listDeliveries(hook.id, 20))
                  .sort((a,b) => Date.parse(b.delivered_at) - Date.parse(a.delivered_at));
                let newest = null;
                for (const d of head) {
                  if (d.event !== key.event || !isRecent(d.delivered_at)) continue;
                  const full = await getDelivery(hook.id, d.id);
                  if (matchesThisEvent(full, key)) { newest = full; break; }
                }

                if (!newest) {
                  core.info('No matching new delivery yet; will retry.');
                  continue;
                }
                if (isSuccess(newest)) {
                  core.info(`‚úÖ Hook ${hook.id}: success after ${attempts} attempt(s).`);
                  return { processed: true, success: true };
                }
                cursorId = newest.id; // –ø—Ä–æ–¥–æ–≤–∂—É—î–º–æ –≤—ñ–¥ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ
              }

              const failMsg = `‚ùå Hook ${hook.id} (${hook.config?.url}) still failing after ${MAX_ATTEMPTS} attempts`;
              core.warning(failMsg);
              return { processed: true, failed: true, message: failMsg };
            }

            // ----- –ü–û–°–õ–Ü–î–û–í–ù–ê –û–ë–†–û–ë–ö–ê –í–°–Ü–• –í–ï–ë–•–£–ö–Ü–í -----
            const hooks = await listRepoHooks();
            const relevantHooks = hooks.filter(h =>
              h.active !== false &&
              (!Array.isArray(h.events) || h.events.includes(thisKey.event) || h.events.includes('*'))
            );

            if (relevantHooks.length === 0) {
              core.info('No active hooks subscribed to this event.');
              return;
            }

            let anyTried = false;
            let anyFailed = false;

            for (const hook of relevantHooks) {
              anyTried = true;
              const res = await redeliverForHook(hook, thisKey); // –ü–û –ß–ï–†–ó–Ü: await –≥–∞—Ä–∞–Ω—Ç—É—î –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å
              if (res?.failed) anyFailed = true;
            }

            if (!anyTried) {
              core.info('No recent failed deliveries found for THIS event.');
            }
            if (anyFailed) {
              core.setFailed('At least one webhook still failing after retries.');
            }
